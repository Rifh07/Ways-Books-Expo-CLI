{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport GestureHandler from \"./GestureHandler\";\nimport { TEST_MAX_IF_NOT_NAN } from \"./utils\";\n\nvar DiscreteGestureHandler = function (_GestureHandler) {\n  _inherits(DiscreteGestureHandler, _GestureHandler);\n\n  var _super = _createSuper(DiscreteGestureHandler);\n\n  function DiscreteGestureHandler() {\n    _classCallCheck(this, DiscreteGestureHandler);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(DiscreteGestureHandler, [{\n    key: \"isDiscrete\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"shouldEnableGestureOnSetup\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"shouldFailUnderCustomCriteria\",\n    value: function shouldFailUnderCustomCriteria(_ref, _ref2) {\n      var x = _ref.x,\n          y = _ref.y,\n          deltaX = _ref.deltaX,\n          deltaY = _ref.deltaY;\n      var maxDeltaX = _ref2.maxDeltaX,\n          maxDeltaY = _ref2.maxDeltaY,\n          maxDistSq = _ref2.maxDistSq,\n          shouldCancelWhenOutside = _ref2.shouldCancelWhenOutside;\n\n      if (shouldCancelWhenOutside) {\n        if (!this.isPointInView({\n          x: x,\n          y: y\n        })) {\n          return true;\n        }\n      }\n\n      return TEST_MAX_IF_NOT_NAN(Math.abs(deltaX), maxDeltaX) || TEST_MAX_IF_NOT_NAN(Math.abs(deltaY), maxDeltaY) || TEST_MAX_IF_NOT_NAN(Math.abs(deltaY * deltaY + deltaX * deltaX), maxDistSq);\n    }\n  }, {\n    key: \"transformNativeEvent\",\n    value: function transformNativeEvent(_ref3) {\n      var _ref3$center = _ref3.center,\n          x = _ref3$center.x,\n          y = _ref3$center.y;\n      var rect = this.view.getBoundingClientRect();\n      return {\n        absoluteX: x,\n        absoluteY: y,\n        x: x - rect.left,\n        y: y - rect.top\n      };\n    }\n  }, {\n    key: \"isGestureEnabledForEvent\",\n    value: function isGestureEnabledForEvent(_ref4, _recognizer, _ref5) {\n      var minPointers = _ref4.minPointers,\n          maxPointers = _ref4.maxPointers,\n          maxDeltaX = _ref4.maxDeltaX,\n          maxDeltaY = _ref4.maxDeltaY,\n          maxDistSq = _ref4.maxDistSq,\n          shouldCancelWhenOutside = _ref4.shouldCancelWhenOutside;\n      var pointerLength = _ref5.maxPointers,\n          center = _ref5.center,\n          deltaX = _ref5.deltaX,\n          deltaY = _ref5.deltaY;\n      var validPointerCount = pointerLength >= minPointers && pointerLength <= maxPointers;\n\n      if (this.shouldFailUnderCustomCriteria(_objectSpread(_objectSpread({}, center), {}, {\n        deltaX: deltaX,\n        deltaY: deltaY\n      }), {\n        maxDeltaX: maxDeltaX,\n        maxDeltaY: maxDeltaY,\n        maxDistSq: maxDistSq,\n        shouldCancelWhenOutside: shouldCancelWhenOutside\n      }) || !validPointerCount && this.isGestureRunning) {\n        return {\n          failed: true\n        };\n      }\n\n      return {\n        success: validPointerCount\n      };\n    }\n  }]);\n\n  return DiscreteGestureHandler;\n}(GestureHandler);\n\nexport default DiscreteGestureHandler;","map":{"version":3,"sources":["D:/Bootcamp/react native/finalProject/node_modules/react-native-gesture-handler/dist/src/web/DiscreteGestureHandler.js"],"names":["GestureHandler","TEST_MAX_IF_NOT_NAN","DiscreteGestureHandler","x","y","deltaX","deltaY","maxDeltaX","maxDeltaY","maxDistSq","shouldCancelWhenOutside","isPointInView","Math","abs","center","rect","view","getBoundingClientRect","absoluteX","absoluteY","left","top","_recognizer","minPointers","maxPointers","pointerLength","validPointerCount","shouldFailUnderCustomCriteria","isGestureRunning","failed","success"],"mappings":";;;;;;;;;;;;;;;AAEA,OAAOA,cAAP;AACA,SAASC,mBAAT;;IACMC,sB;;;;;;;;;;;;;SACF,eAAiB;AACb,aAAO,IAAP;AACH;;;SACD,eAAiC;AAC7B,aAAO,IAAP;AACH;;;WACD,oDAAsH;AAAA,UAAtFC,CAAsF,QAAtFA,CAAsF;AAAA,UAAnFC,CAAmF,QAAnFA,CAAmF;AAAA,UAAhFC,MAAgF,QAAhFA,MAAgF;AAAA,UAAxEC,MAAwE,QAAxEA,MAAwE;AAAA,UAA5DC,SAA4D,SAA5DA,SAA4D;AAAA,UAAjDC,SAAiD,SAAjDA,SAAiD;AAAA,UAAtCC,SAAsC,SAAtCA,SAAsC;AAAA,UAA3BC,uBAA2B,SAA3BA,uBAA2B;;AAClH,UAAIA,uBAAJ,EAA6B;AACzB,YAAI,CAAC,KAAKC,aAAL,CAAmB;AAAER,UAAAA,CAAC,EAADA,CAAF;AAAKC,UAAAA,CAAC,EAADA;AAAL,SAAnB,CAAL,EAAmC;AAC/B,iBAAO,IAAP;AACH;AACJ;;AACD,aAAQH,mBAAmB,CAACW,IAAI,CAACC,GAAL,CAASR,MAAT,CAAD,EAAmBE,SAAnB,CAAnB,IACJN,mBAAmB,CAACW,IAAI,CAACC,GAAL,CAASP,MAAT,CAAD,EAAmBE,SAAnB,CADf,IAEJP,mBAAmB,CAACW,IAAI,CAACC,GAAL,CAASP,MAAM,GAAGA,MAAT,GAAkBD,MAAM,GAAGA,MAApC,CAAD,EAA8CI,SAA9C,CAFvB;AAGH;;;WACD,qCAA2C;AAAA,+BAApBK,MAAoB;AAAA,UAAVX,CAAU,gBAAVA,CAAU;AAAA,UAAPC,CAAO,gBAAPA,CAAO;AAEvC,UAAMW,IAAI,GAAG,KAAKC,IAAL,CAAUC,qBAAV,EAAb;AACA,aAAO;AACHC,QAAAA,SAAS,EAAEf,CADR;AAEHgB,QAAAA,SAAS,EAAEf,CAFR;AAGHD,QAAAA,CAAC,EAAEA,CAAC,GAAGY,IAAI,CAACK,IAHT;AAIHhB,QAAAA,CAAC,EAAEA,CAAC,GAAGW,IAAI,CAACM;AAJT,OAAP;AAMH;;;WACD,yCAAkHC,WAAlH,SAAuL;AAAA,UAA5JC,WAA4J,SAA5JA,WAA4J;AAAA,UAA/IC,WAA+I,SAA/IA,WAA+I;AAAA,UAAlIjB,SAAkI,SAAlIA,SAAkI;AAAA,UAAvHC,SAAuH,SAAvHA,SAAuH;AAAA,UAA5GC,SAA4G,SAA5GA,SAA4G;AAAA,UAAjGC,uBAAiG,SAAjGA,uBAAiG;AAAA,UAAzCe,aAAyC,SAAtDD,WAAsD;AAAA,UAA1BV,MAA0B,SAA1BA,MAA0B;AAAA,UAAlBT,MAAkB,SAAlBA,MAAkB;AAAA,UAAVC,MAAU,SAAVA,MAAU;AACnL,UAAMoB,iBAAiB,GAAGD,aAAa,IAAIF,WAAjB,IAAgCE,aAAa,IAAID,WAA3E;;AACA,UAAI,KAAKG,6BAAL,iCAAwCb,MAAxC;AAAgDT,QAAAA,MAAM,EAANA,MAAhD;AAAwDC,QAAAA,MAAM,EAANA;AAAxD,UAAkE;AAClEC,QAAAA,SAAS,EAATA,SADkE;AAElEC,QAAAA,SAAS,EAATA,SAFkE;AAGlEC,QAAAA,SAAS,EAATA,SAHkE;AAIlEC,QAAAA,uBAAuB,EAAvBA;AAJkE,OAAlE,KAQC,CAACgB,iBAAD,IAAsB,KAAKE,gBARhC,EAQmD;AAC/C,eAAO;AAAEC,UAAAA,MAAM,EAAE;AAAV,SAAP;AACH;;AACD,aAAO;AAAEC,QAAAA,OAAO,EAAEJ;AAAX,OAAP;AACH;;;;EAzCgC1B,c;;AA2CrC,eAAeE,sBAAf","sourcesContent":["/* eslint-disable eslint-comments/no-unlimited-disable */\n/* eslint-disable */\nimport GestureHandler from './GestureHandler';\nimport { TEST_MAX_IF_NOT_NAN } from './utils';\nclass DiscreteGestureHandler extends GestureHandler {\n    get isDiscrete() {\n        return true;\n    }\n    get shouldEnableGestureOnSetup() {\n        return true;\n    }\n    shouldFailUnderCustomCriteria({ x, y, deltaX, deltaY }, { maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside }) {\n        if (shouldCancelWhenOutside) {\n            if (!this.isPointInView({ x, y })) {\n                return true;\n            }\n        }\n        return (TEST_MAX_IF_NOT_NAN(Math.abs(deltaX), maxDeltaX) ||\n            TEST_MAX_IF_NOT_NAN(Math.abs(deltaY), maxDeltaY) ||\n            TEST_MAX_IF_NOT_NAN(Math.abs(deltaY * deltaY + deltaX * deltaX), maxDistSq));\n    }\n    transformNativeEvent({ center: { x, y } }) {\n        // @ts-ignore FIXME(TS)\n        const rect = this.view.getBoundingClientRect();\n        return {\n            absoluteX: x,\n            absoluteY: y,\n            x: x - rect.left,\n            y: y - rect.top,\n        };\n    }\n    isGestureEnabledForEvent({ minPointers, maxPointers, maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside, }, _recognizer, { maxPointers: pointerLength, center, deltaX, deltaY }) {\n        const validPointerCount = pointerLength >= minPointers && pointerLength <= maxPointers;\n        if (this.shouldFailUnderCustomCriteria({ ...center, deltaX, deltaY }, {\n            maxDeltaX,\n            maxDeltaY,\n            maxDistSq,\n            shouldCancelWhenOutside,\n        }) ||\n            // A user probably won't land a multi-pointer tap on the first tick (so we cannot just cancel each time)\n            // but if the gesture is running and the user adds or subtracts another pointer then it should fail.\n            (!validPointerCount && this.isGestureRunning)) {\n            return { failed: true };\n        }\n        return { success: validPointerCount };\n    }\n}\nexport default DiscreteGestureHandler;\n"]},"metadata":{},"sourceType":"module"}